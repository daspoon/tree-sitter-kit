/*

*/

import TreeSitterCLI
import Foundation


  // Maintain the pairing of status code and text returned by the call to `swiftgen`.
fileprivate class Result {
  let status : Int
  let text : NSString
  init(status: UInt32, textBytes: UnsafePointer<UInt8>?, textLen: UInt32) {
    if let textBytes {
      if let text = NSString(bytes: textBytes, length: Int(textLen), encoding: NSUTF8StringEncoding) {
        self.status = Int(status)
        self.text = text
      } else {
        self.status = -1
        self.text = "Failed to interpret generated bytes as UTF8"
      }
    } else {
      self.status = -1
      self.text = "Pointer to generated bytes is null"
    }
  }
}


/// Return the Swift parser source for a grammar expressed as JSON and the access modifier applied to enclosing struct.
package func generateParserSource(for jsonText: String, accessModifier modText: String = "", abi_version v: UInt32 = 0) throws -> String {
  // We must call tree-sitter in a context where the contiguous utf8 representations of the grammar and visibility strings are available...
  let optionalOptionalSwiftText = try jsonText.utf8.withContiguousStorageIfAvailable { jsonBuf in
    try modText.utf8.withContiguousStorageIfAvailable { modBuf in
      try generateParserSource(for: jsonBuf, accessModifier: modBuf, abi_version: v)
    }
  }

  // The generated source will be nil if either of the grammar or visibility text have no contiguous UTF8 representation.
  guard let optionalSwiftText = optionalOptionalSwiftText, let swiftText = optionalSwiftText
    else { throw Exception("given text lacks a contiguous UTF8 representation") }

  return swiftText
}

/// Return the Swift parser source for a grammar expressed as a UTF8-encoding JSON text.
package func generateParserSource(for jsonBuf: UnsafeBufferPointer<UInt8>, accessModifier modBuf: UnsafeBufferPointer<UInt8>, abi_version v: UInt32 = 0) throws -> String {
  guard jsonBuf.count <= Int(UInt32.max)
    else { throw Exception("grammar text is too long") }
  guard modBuf.count <= Int(UInt32.max)
    else { throw Exception("visibility text is too long") }

  // Invoke tree-sitter with a completion callback that returns a retained instance of Result as an opaque pointer.
  let optionalUnsafeRawPointer = swiftgen(jsonBuf.baseAddress, UInt32(jsonBuf.count), modBuf.baseAddress, UInt32(modBuf.count), v) {
    let result = Result(status: $0, textBytes: $1, textLen: $2)
    return UnsafeRawPointer(Unmanaged.passRetained(result).toOpaque())
  }

  // The call to 'swiftgen' returns the result of the completion callback, so that value must be non-nil.
  guard let unsafeRawPointer = optionalUnsafeRawPointer
    else { throw Exception("unexpected null pointer") }

  // Extract and take ownership of the Result object: throw if the call was unsuccessful, or return the generated text otherwise.
  let result = Unmanaged<Result>.fromOpaque(unsafeRawPointer).takeRetainedValue()
  guard result.status == 0
    else { throw Exception(code: result.status, failureReason: result.text as String) }
  return result.text as String
}
