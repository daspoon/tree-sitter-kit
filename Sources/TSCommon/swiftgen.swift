/*

  Created by David Spooner

*/

import TreeSitterCLI
import Foundation


  // Maintain the pairing of status code and text returned by the call to `swiftgen`.
fileprivate class Result {
  let status : Int
  let text : NSString
  init(status: UInt32, textBytes: UnsafePointer<UInt8>?, textLen: UInt32) {
    if let textBytes {
      if let text = NSString(bytes: textBytes, length: Int(textLen), encoding: NSUTF8StringEncoding) {
        self.status = Int(status)
        self.text = text
      } else {
        self.status = -1
        self.text = "Failed to interpret generated bytes as UTF8"
      }
    } else {
      self.status = -1
      self.text = "Pointer to generated bytes is null"
    }
  }
}


/// Return the Swift parser source for a grammar expressed as JSON text.
public func generateParserSource(for jsonText: String, abi_version v: UInt32 = 0) throws -> String {
  let optionalSwiftText = try jsonText.utf8.withContiguousStorageIfAvailable {
    try generateParserSource(for: $0, abi_version: v)
  }

  // `optionalSwiftText` will be nil iff withContiguousStorageIfAvailable returned nil.
  guard let swiftText = optionalSwiftText
    else { throw Exception("given text lacks a contiguous UTF8 representation") }

  return swiftText
}

/// Return the Swift parser source for a grammar expressed as a UTF8-encoding JSON text.
public func generateParserSource(for jsonBuf: UnsafeBufferPointer<UInt8>, abi_version: UInt32 = 0) throws -> String {
  // Invoke the parser generator with the bytes of the JSON grammar and a callback which returns a retained instance of Result as an opaque pointer.
  guard jsonBuf.count <= Int(UInt32.max)
    else { throw Exception("grammar text is too long") }

  let optionalUnsafeRawPointer = swiftgen(jsonBuf.baseAddress, UInt32(jsonBuf.count), abi_version) {
    let result = Result(status: $0, textBytes: $1, textLen: $2)
    return UnsafeRawPointer(Unmanaged.passRetained(result).toOpaque())
  }

  // `optionalUnsafeRawPointer` is the result of the completion argument to swiftgen, so should not be nil.
  guard let unsafeRawPointer = optionalUnsafeRawPointer
    else { throw Exception("unexpected null pointer") }

  // Extract and 'autorelease' the Result object.
  let result = Unmanaged<Result>.fromOpaque(unsafeRawPointer).takeRetainedValue()
  guard result.status == 0
    else { throw Exception(code: result.status, failureReason: result.text as String) }

  // If successful, return the generated text.
  return result.text as String
}
